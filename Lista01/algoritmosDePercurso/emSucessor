emSucessor(no) {
    if(no == null){
        return null;
    }

    // Caso 1: tem filho à direita
    if(no.dir != null){
        return emPrimeiro(no.dir);
    }

    //subir ate q atual não seja filho direito de u (
    // significa que a sub. arv esquerda foi processada
    // e que u é o proximo nó a ser processado)

    u = no.pai;
    atual = no;
    while(u != null && atual == u.dir){
        atual = u;
        u = u.pai;
    }

    return u;  // pode ser null (se no era o maior da árvore)
}

1. vamos checar se não é nulo
2. se tiver filho a direita vamos chamar o algoritmo emPrimeiro(pois ele vai percorrer a sub arv e retornar o mais esq ou a raiz)
3. se não tem filho a dir vamos fazer um looping subindo os pais de cada nó
4. vamos subir até que, ou u seja nulo ou atual não seja filho direito de seu pai(isso implica em atual ser a raiz de uma sub. arv a esquerda,
logo o proximo nó a ser processado em ordem é seu pai)